Ein wesentlicher Teil dieser Arbeit besteht in der softwareseitigen Realisierung
der Laserstabilisierung und Experimentsteuerung. In diesem Kapitel sollen daher
alle Softwarekomponenten genauer betrachtet werden. Abschnitt
\ref{sec:datenerfassung_der_laser} wird beschrieben, wie die Informationen
der Laserfrequenzen aus der Counterkarte ausgelesen, im
Mikrocontroller \textit{Arduino} aufbereitet und anschließend am PC ausgewertet
werden. In Abschn. \ref{sec:stabilisierung_scan-strategie} wird die Regelung
der Laserfrequenz und der damit verbundenen Strategie der Frequenzverstimmung
erklärt. Abschnitt \ref{sec:linearisierung_iscan} beschäftigt sich mit der
Linearisierung der iScans und dem Neuschreiben der LUT. Die
Benutzerschnittstelle zur Experimentsteuerung soll in Abschn.
\ref{sec:experimentsteuerung} behandelt werden. In Abschn. \ref{sec:sonstiges}
werden weitere Funktionen kurz angerissen. Da die Software am PC in
Labview entwickelt wurde und somit der Code nur sehr platzverschwendend
dargestellt werden kann, wird die Beschreibung ausschließlich über
Ablaufdiagramme und Bildschirmfotos der Benutzeroberfläche geschehen. Der
Quellcode des Labview-Programms kann am Kontrollrechner selbst eingesehen
werden. Programme in Labview werden im Folgenden \textit{Virtuelles
Instrument} (VI) bzw. SubVI (Unterprogramm) genannt.

\section{Datenerfassung der Laser}\label{sec:datenerfassung_der_laser}
Die Informationen der Laser durchlaufen mehrere Stufen der Signal- und
Datenverarbeitung, bis eine quantitative Aussage über das Frequenzverhalten
gemacht werden und eine Regelroutine anlaufen kann. Der erste Teil der
Datenaufbereitung verläuft rein elektronisch, bis die Counterwerte binär in
den Counterregistern abrufbereit vorliegen, wie bereits in Abschn.
\ref{sec:elektronik_laserkontrolle} ausführlich erklärt wurde. An dieser Stelle
setzt nun die softwareseitige Weiterverarbeitung an. Im Folgenden wird sich
wieder exemplarisch nur auf einen Diodenlaser und den Referenzlaser bezogen.
Für alle anderen Laser gilt der identische Ablauf.

\subsection{Datenaufbereitung}\label{subsec:datenaufbereitung}
Zunächst werden die Counterwerte mit Hilfe des Mikrocontrollers \textit{Arduino}
ausgelesen und verarbeitet. Das komplette Ablaufdiagramm der Software des
\textit{Arduinos} ist in Abb. \ref{fig:ablaufdiagramm_arduino_laser} in auf die
wesentlichen Teile gekürzter Form zu sehen. Der komplette Quellcode hierfür
wurde in der Programmiersprache C geschrieben und ist im Anhang
\ref{anh:kap:quelltext_arduino_laserinformationsverarbeitung} zu finden.
\begin{figure}[hp]
 	\centering
 	\fbox{\parbox{\dimexpr \linewidth - 2\fboxrule - 2\fboxsep}{
 	\centering
	    \includegraphics[width=\textwidth-0.5cm]{gfx/ablaufdiagramm_arduino_laser}
	    }}
	\caption[Laserdatenaufbereitung -
	Ablaufdiagramm]{Ablaufdiagramm der
	Laserdatenaufbereitung}\label{fig:ablaufdiagramm_arduino_laser}
\end{figure}
Der \textit{Arduino} verfügt über 54 digitale Ein- und Ausgänge, welche der
Kommunikation mit der Counterkarte dienen. HIGH ($5\,$V) bzw. LOW ($0\,$V) wird
als 1 oder TRUE bzw. 0 oder FALSE interpretiert. Das Programm besteht aus einem \textit{Setup}, in dem initialisierende Routinen wie die Pinbelegung
abgearbeitet werden, und einer \textit{Endlosschleife}
(\textit{Start}$\rightarrow$\textit{Programm}$\rightarrow$\textit{Stop}$\rightarrow$\textit{Start}$\rightarrow$\ldots),
über die die stetige Überwachung der Laser abgewickelt wird. Die Aufgaben des
Programms sind
\begin{itemize}
	\item Counter auslesen
	\item reale Zeiten berechnen
	\item unplausible Zeiten ignorieren
	\item FSR-Sprünge erkennen und Zeiten korrigieren
	\item Mittelwerte der Zeiten bilden.
	\item Laser-Jitter berechnen.
\end{itemize}
All dies muss innerhalb eines Rampenzyklusses (also innerhalb von maximal
$17\,$ms) geschehen, damit keine Information verloren geht. Im schlimmsten Fall
bleibt dem Mikrocontroller für die Berechnungen nach dem Auslesen der Counter
nur ca. $2\,$ms (fallende Rampe). Aus diesem Grund wurde das Programm möglichst
performand programmiert.\par Es wird immer eine bestimmte Anzahl von Rampenzyklen zusammengefasst und Zeitmittelwerte für die Offset- und Interfringezeiten beider Laser ($t_{OR,i}$,
$t_{OD,i}$, $t_{IR,i}$ und $t_{ID,i}$) berechnet. Weiterhin wird aus der
Standardabweichung der Offsetfringezeiten der Jitter
\begin{equation}\label{eq:jitter_zeit}
	\Delta
	t_O=\sqrt{\frac{1}{n-1}\cdot\sum\limits_{i=1}^{n}\left(t_{O,i}-\overline{t}_O\right)^2}
\end{equation}
des jeweiligen Lasers über die Anzahl der zu mittelnden Rampenzyklen
ermittelt.\par
Eine Iteration beginnt - wenn nötig - mit dem Warten bis alle
Counter zurückgesetzt wurden, indem geprüft wird, ob alle Status-Bits LOW sind, was irgendwann während der fallenden Rampe geschieht.
Anschließend werden die Counter ausgelesen. Dabei wird in einer Schleife zu
Beginn geprüft, ob bereits alle Counter ausgelesen worden sind. Wenn dies nicht
der Fall ist, wird über die Status-Bits auf die Bereitschaft irgendeines
Counters gewartet und im Falle der Bereitschaft geprüft, ob der Counter schon
ausgelesen worden ist. Wurden die Werte noch nicht ausgelesen, werden upper und
lower Byte nacheinander adressiert und ausgelesen.\par
Aus den erhaltenen 16-Bit-Werten werden nun über die fest einprogrammierte
Taktrate die wirklichen Zeiten berechnet. Über die komplette Zeit, in der das
Programm läuft, werden nach jeder Iteration Allzeitmittelwerte für die
Interfringezeiten erneuert. Zu Beginn des Programms werden diese mit den ersten
Zeiten initialisiert. Mit Hilfe der Allzeitmittelwerte wird geprüft, ob die
aktuellen Interfringezeiten valide sind. Es kann insbesondere bei schnellen
Frequenzverstimmungen vorkommen, dass während einer Rampe der Interfringe aus
dem aktuellen FSR hinausläuft, noch bevor der Counter gestoppt wurde und
somit eine falsche Zeit gemessen wird. Um diese Fälle und andere Fehlmessungen
auszusondern, wird geprüft, ob die gemessene Interfringezeit stark vom
Allzeitmittelwert abweicht. Bei offensichtlich falscher Messung wird die
momentane Iteration abgebrochen und für die spätere Ausgabe ein
Validitätsvariable auf 0 gesetzt, damit bei der Weiterverarbeitung am PC
entschieden werden kann, ob die Daten genutzt werden möchten oder nicht.\par
Sind die Zeiten valide, kann herausgefunden werden, ob die Laserfrequenz des Diodenlaser in den nächsten FSR des FPIs gelaufen ist. Dabei wird
überprüft, ob sich die Zeit des Offsetfringes relativ zur Offsetfringezeit des
Referenzlasers gegenüber der Zeit der vorherigen Rampe um mehr als die Hälfte
der Interfringezeit verändert hat. Folgendes kann auftreten:
\begin{subequations}\label{eq:FSR-sprung}
	\begin{equation}\label{eq:FSR-sprung_links}
		(t_{OD,akt.}-t_{OR,akt.})-(t_{OD,alt}-t_{OR,alt})>\nicefrac{1}{2}\cdot
t_{ID,akt}
	\end{equation}
	\begin{equation}\label{eq:FSR-sprung_rechts}
		(t_{OD,akt.}-t_{OR,akt.})-(t_{OD,alt}-t_{OR,alt})<-\nicefrac{1}{2}\cdot
t_{ID,akt}\,.
	\end{equation}
\end{subequations}
Gilt \eqref{eq:FSR-sprung_links}, so wird vermutet, dass der Laser in den links
benachbarten FSR gedriftet ist. Im Falle von \eqref{eq:FSR-sprung_rechts} ist
der Laser vermutlich in den rechts benachbarten FSR gedriftet. In
beiden Fällen wird eine FSR-Nummer-Variable erniedrigt bzw. erhöht, um später am
PC die FSR-Sprünge zählen zu können. Die Detektion kann natürlich wie schon
erwähnt nur funktionieren, wenn die Frequenz deutlich langsamer als $\nicefrac{1}{2}\text{FSR}$ pro Rampenzyklus verstimmt wird. Damit auch bei FSR-Sprüngen die Zeiten zur Mittelung beitragen können,
werden diese anschleißend durch subtrahieren bzw. addieren der Interfringezeit
korrigiert.\par
Für den Referenzlaser ist ein FSR-Sprung aufgrund seiner absoluten Stabilität
bis auf wenige MHz praktisch unmöglich, sofern des Offset der Rampe so
eingestellt ist, dass der erste Fringe ca.
$\nicefrac{1}{2}\text{FSR}$ nach Start der Rampe auftaucht. Somit bleibt die
Laserfrequenz mit aller Sicherheit immer in demselben FSR des FPIs. Es
kommt jedoch vor, dass die Rampe oder das FPI einem Drift unterliegen
und der Referenzlaser scheinbar in einen benachbarten FSR driftet.
Analog wie beim Diodenlaser wird auch hier der scheinbare FSR-Sprung
detektiert. In diesem Fall wird aber lediglich die Offsetfringezeit wie beim
Diodenlaser korrigiert. Die Zählvariable für den scheinbaren FSR-Sprung
wird nur noch zu Debugzwecken aufbewahrt. Logischerweise können
gleichzeitige FSR-Sprünge beider Laser so nicht erkannt werden. In diesem
sehr unwahrscheinlichen Fall käme es zu Fehlberechnungen der Relativfrequenz.
Um dennoch sicher zu sein, sollte deshalb regelmäßig auf die Lage des ersten
He:Ne-Fringes geachtet und ggf. das Offset der Rampe nachkorrigiert werden.\par
Wurden genügend Rampen durchlaufen, können die aktuellen Mittelwerte aller
Zeiten und die Varianzen der Offsetfringezeiten berechnet und mit allen anderen nötigen Werten über RS232 an den PC gesandt werden (brauner Kasten in Abb.
\ref{fig:ablaufdiagramm_arduino_laser}). Der String der versendet wird, beginnt
mit \lstinline|"*begin*"| und endet mit \lstinline|"*end*"|, damit später mit
sichergestellt werden kann, wo die Daten anfangen und aufhören. Die Werte sind
untereinander durch Leerzeichen getrennt.

\subsection{Datenbereitstellung am PC}\label{subsec:datenbereitstellung}
Die Daten eines jeden Lasers kommen wie oben erwähnt als String in Zeitabständen
eines Vielfachen der Rampendauer am PC an. Damit es zu keinem Pufferstau an
der seriellen Schnittstelle des PCs kommt, werden die aktuellen Strings direkt
nach Abschneiden von \lstinline|"*begin*"| und \lstinline|"*end*"| durch das
SubVI \lstinline|arduino_laser_read.vi| in globale Variablen geschrieben.
Parallel wird jeweils eine boolsche Variable gesetzt, die angibt, dass die Laserinformationen aktuell sind. Wird ein String aus einer der
globalen Variablen gelesen, wird die boolsche Variable zurückgesetzt und die
Laserinformationen werden als nicht mehr aktuell gewertet. Aktualität fordernde
Lesezugriffe auf die Daten warten, bis die Variable wieder gesetzt wurde. Die
aktuellen Zeiten können nun separat über das SubVI
\lstinline|get_laser_times.vi| nach Angabe der Lasernummer abgeholt werden. Das SubVI \lstinline|delta_time2delta_frequency.vi| berechnet nach Gl. \eqref{eq:FPI_frequenzdrift_03} aus den Zeiten die
Relativfrequenzen. Das SubVI \lstinline|laser-control.vi|, die in Abschn. \ref{sec:stabilisierung_frequenzverstimmungs-strategie} näher betrachtet wird, hat neben
der Regelung und Frequenzverstimmtung auf die Sollfrequenz auch die Aufgabe
Monitoringdaten an die Benutzeroberfläche der Laserkontrolle (Abb.
\ref{fig:benutzeroberflaeche_laserkontrolle}) weiterzugeben. Zu den
Monitoringdaten gehören Jitter des Lasers, Ist-Relativfrequenz und Abweichung
zur Soll-Relativfrequenz, wobei die detektierten FSR-Sprünge mit einbezogen
werden müssen. Die Referenzfrequenz ist beim Start des Programms oder beim
Drücken des Buttons \lstinline|assign| die derzeit aktuelle Laserfrequenz.
\begin{figure}[hp]
 	\centering
 	\fbox{\parbox{\dimexpr \linewidth - 2\fboxrule - 2\fboxsep}{
 	\centering
	    \includegraphics[width=\textwidth-0.5cm]{gfx/benutzeroberflaeche_laserkontrolle}
	    }}
	\caption[Benutzeroberfläche -
	Laserkontrolle]{Benutzeroberfläche
	der Laserkontrolle}\label{fig:benutzeroberflaeche_laserkontrolle}
\end{figure}

\section{Stabilisierung/Frequenzverstimmungs-Strategie}\label{sec:stabilisierung_frequenzverstimmungs-strategie}
Frequenzverstimmung und gleichzeitige Regelung wird von der SubVI
\lstinline|laser-control.vi| verwaltet. Die Anforderungen sind möglichst
schnelles Anfahren der Sollfrequenz, egal, wie groß die Verstimmung ist, und
anschließendes Regeln. Grundidee ist, dass der Laser über das \textit{iScan}
sehr schnell in den Bereich der Sollfrequenz gefahren wird und anschließend mit Hilfe
des Fringe-Offset-Locking nachgeregelt wird, da ein direktes Anfahren mit dem
\textit{iScan} aufgrund seiner Nichtliniearität unmöglich ist. In
\ref{kap:charakterisierung} wird sich zeigen, dass der Fehler bei alleiniger
Verstimmung mit dem \textit{iScan} wenige bis mehr als $100\,$MHz sein kann.
Dies bedarf einer nicht-trivialen Strategie, die mit Hilfe von
\ref{fig:frequenzverstimmungs-strategie} und dem Ablaufdiagramm
\ref{fig:frequenzverstimmungs-strategie_ablaufdiagramm} veranschaulicht werden
soll.\par
Zunächst soll
